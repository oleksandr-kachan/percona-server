include/master-slave.inc
Warnings:
Note	####	Sending passwords in plain text without SSL/TLS is extremely insecure.
Note	####	Storing MySQL user name or password information in the master info repository is not secure and is therefore not recommended. Please consider using the USER and PASSWORD connection options for START SLAVE; see the 'START SLAVE Syntax' in the MySQL Manual for more information.
[connection master]
[connection master]
create procedure save_read_stats()
begin
select variable_value into @rr from performance_schema.global_status
where variable_name='rocksdb_rows_read';
select variable_value into @ru from performance_schema.global_status
where variable_name='rocksdb_rows_updated';
select variable_value into @rd from performance_schema.global_status
where variable_name='rocksdb_rows_deleted';
end//
create procedure get_read_stats()
begin
select variable_value - @rr as rows_read from
performance_schema.global_status
where variable_name='rocksdb_rows_read';
select variable_value - @ru as rows_updated from
performance_schema.global_status
where variable_name='rocksdb_rows_updated';
select variable_value - @rd as rows_deleted from
performance_schema.global_status
where variable_name='rocksdb_rows_deleted';
end//
create table t1 (id int primary key, value int) Engine=RocksDB;
insert into t1 values (1,1), (2,2), (3,3), (4,4);
include/sync_slave_sql_with_master.inc

# regular update/delete. With rocks_read_free_rpl_tables=.*, rocksdb_rows_read does not increase on slaves

[connection slave]
call save_read_stats();
[connection master]
update t1 set value=value+1 where id=1;
delete from t1 where id=4;
select * from t1;
id	value
1	2
2	2
3	3
include/sync_slave_sql_with_master.inc
[connection slave]
call get_read_stats();
rows_read
0
rows_updated
1
rows_deleted
1
select * from t1;
id	value
1	2
2	2
3	3

# "rocks_read_free_rpl_tables=.*" makes "row not found error" not happen anymore

[connection slave]
include/stop_slave.inc
delete from t1 where id in (2, 3);
include/start_slave.inc
call save_read_stats();
[connection master]
update t1 set value=value+1 where id=3;
delete from t1 where id=2;
select * from t1;
id	value
1	2
3	4
include/sync_slave_sql_with_master.inc
[connection slave]
call get_read_stats();
rows_read
0
rows_updated
1
rows_deleted
1
select * from t1;
id	value
1	2
3	4

## tables without primary key -- read free replication should be disabled


#no index

[connection master]
drop table t1;
create table t1 (c1 int, c2 int) Engine=RocksDB;
insert into t1 values (1,1), (2,2),(3,3),(4,4),(5,5);
include/sync_slave_sql_with_master.inc
[connection slave]
call save_read_stats();
[connection master]
update t1 set c2=100 where c1=3;
delete from t1 where c1 <= 2;
include/sync_slave_sql_with_master.inc
[connection slave]
call get_read_stats();
rows_read
5
rows_updated
1
rows_deleted
2
select * from t1;
c1	c2
3	100
4	4
5	5

#secondary index only

[connection master]
drop table t1;
create table t1 (c1 int, c2 int, index i(c1)) Engine=RocksDB;
insert into t1 values (1,1), (2,2),(3,3),(4,4),(5,5);
include/sync_slave_sql_with_master.inc
[connection slave]
call save_read_stats();
[connection master]
update t1 set c2=100 where c1=3;
delete from t1 where c1 <= 2;
include/sync_slave_sql_with_master.inc
[connection slave]
call get_read_stats();
rows_read
3
rows_updated
1
rows_deleted
2
select * from t1;
c1	c2
3	100
4	4
5	5

## large row operations -- primary key modification, secondary key modification

[connection master]
drop table t1;
create table t1 (id1 bigint, id2 bigint, c1 bigint, c2 bigint, c3 bigint, c4 bigint, c5 bigint, c6 bigint, c7 bigint, primary key (id1, id2), index i(c1, c2)) Engine=RocksDB;
include/sync_slave_sql_with_master.inc
[connection slave]
call save_read_stats();
[connection master]

#updating all seconary keys by 1

include/sync_slave_sql_with_master.inc
[connection slave]
call get_read_stats();
rows_read
0
rows_updated
10000
rows_deleted
0
[connection master]
include/diff_tables.inc [master:t1, slave:t1]

#updating all primary keys by 2

[connection slave]
call save_read_stats();
[connection master]
include/sync_slave_sql_with_master.inc
[connection slave]
call get_read_stats();
rows_read
0
rows_updated
10000
rows_deleted
0
[connection master]
include/diff_tables.inc [master:t1, slave:t1]

#updating secondary keys after truncating t1 on slave

[connection slave]
truncate table t1;
call save_read_stats();
[connection master]
update t1 set c2=c2+10;
include/sync_slave_sql_with_master.inc
[connection slave]
call get_read_stats();
rows_read
0
rows_updated
10000
rows_deleted
0
[connection master]
include/diff_tables.inc [master:t1, slave:t1]

#updating primary keys after truncating t1 on slave

[connection slave]
truncate table t1;
call save_read_stats();
[connection master]
update t1 set id2=id2+10;
include/sync_slave_sql_with_master.inc
[connection slave]
call get_read_stats();
rows_read
0
rows_updated
10000
rows_deleted
0
[connection master]
include/diff_tables.inc [master:t1, slave:t1]

#deleting half rows

[connection slave]
call save_read_stats();
[connection master]
delete from t1 where id1 <= 5000;
include/sync_slave_sql_with_master.inc
[connection slave]
call get_read_stats();
rows_read
0
rows_updated
0
rows_deleted
5000
[connection master]
include/diff_tables.inc [master:t1, slave:t1]
[connection master]
[on master]
create table t2 (id int primary key, i1 int, i2 int, value int, index(i1), index(i2)) Engine=RocksDB;
create table u2 (id int primary key, i1 int, i2 int, value int, index(i1), index(i2)) Engine=RocksDB;
insert into t2 values (1,1,1,1),(2,2,2,2),(3,3,3,3);
insert into u2 values (1,1,1,1),(2,2,2,2),(3,3,3,3);
include/sync_slave_sql_with_master.inc
[connection slave]
[on slave]
delete from t2 where id <= 2;
delete from u2 where id <= 2;
[connection master]
[on master]
update t2 set i2=100, value=100 where id=1;
update u2 set i2=100, value=100 where id=1;
[connection slave]
[on slave]
call mtr.add_suppression("Slave SQL.*Could not execute Update_rows event on table test.u2.*Error_code.*");
call mtr.add_suppression("Slave: Can't find record in 'u2'.*");
include/wait_for_slave_sql_error.inc [errno=1032]
[connection slave]
select count(*) from t2 force index(primary);
count(*)
2
select count(*) from t2 force index(i1);
count(*)
1
select count(*) from t2 force index(i2);
count(*)
2
select * from t2 where id=1;
id	i1	i2	value
1	1	100	100
select i1 from t2 where i1=1;
i1
select i2 from t2 where i2=100;
i2
100
select count(*) from u2 force index(primary);
count(*)
1
select count(*) from u2 force index(i1);
count(*)
1
select count(*) from u2 force index(i2);
count(*)
1
select * from u2 where id=1;
id	i1	i2	value
select i1 from u2 where i1=1;
i1
select i2 from u2 where i2=100;
i2
include/wait_for_slave_sql_to_start.inc

# some tables with read-free replication on and some with it off
# secondary keys have extra rows

[connection master]
[on master]
create table t3 (id int primary key, i1 int, i2 int, value int, index(i1), index(i2)) Engine=RocksDB;
create table u3 (id int primary key, i1 int, i2 int, value int, index(i1), index(i2)) Engine=RocksDB;
insert into t3 values (1,1,1,1),(2,2,2,2),(3,3,3,3);
insert into u3 values (1,1,1,1),(2,2,2,2),(3,3,3,3);
include/sync_slave_sql_with_master.inc
[connection slave]
[on slave]
update t3 set i1=100 where id=1;
update u3 set i1=100 where id=1;
[connection master]
[on master]
delete from t3 where id=1;
delete from u3 where id=1;
include/sync_slave_sql_with_master.inc
[connection slave]
[on slave]
select count(*) from t3 force index(primary);
count(*)
2
select count(*) from t3 force index(i1);
count(*)
2
select count(*) from t3 force index(i2);
count(*)
2
select i1 from t3 where i1=100;
i1
100
select count(*) from u3 force index(primary);
count(*)
2
select count(*) from u3 force index(i1);
count(*)
2
select count(*) from u3 force index(i2);
count(*)
2
select i1 from u3 where i1=100;
i1
[connection master]
drop table t1, t2, t3, u2, u3;
drop procedure save_read_stats;
drop procedure get_read_stats;
include/rpl_end.inc
